/******************************************************************************
* $HeadURL: https://svnpub.iter.org/codac/iter/codac/dev/units/m-sdn/trunk/src/main/c/src/sdn_node_info.cpp $
* $Id: sdn_node_info.cpp 36365 2013-04-30 13:18:59Z kimh12 $
*
* Project		: CODAC Core System
*
* Description	: SDN Software - Communication API SdnNodeInfo source file.
*
* Author        : Eui Jae LEE, Hyung Gi KIM (Mobiis Co., Ltd)
*
* Co-Author     : Mahajan Kirti
*
* Copyright (c) : 2010-2013 ITER Organization,
*				  CS 90 046
*				  13067 St. Paul-lez-Durance Cedex
*				  France
*
* This file is part of ITER CODAC software.
* For the terms and conditions of redistribution or use of this software
* refer to the file ITER-LICENSE.TXT located in the top level directory
* of the distribution package.
******************************************************************************/

/*! \file sdn_node_info.cpp 
 *  \brief Implements SDN intialization API 
 */

#include <sys/types.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <iostream>
#include <fstream>
#include <list>
#include <string.h>
#include <sys/mman.h>
#include <sched.h>
#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/ioctl.h> 
#include <linux/netdevice.h> 
#include <fcntl.h>
#include <netdb.h>
#include <errno.h>

#include "../include/sdn/sdn_typedef.h"
#include "../include/sdn/sdn_node_info.h"
#include "../include/sdn_common/log_buffer.h"

#include "../include/sdn_common/sdnmon_msg.h"
#include "../include/sdn_common/sdnmon_msg_reg.h"

using namespace std; 


/** \var SdnNodeInfo g_NodeInfo
 *	\brief A single instance of SdnNodeInfo required by the application per node.
 */
SdnNodeInfo g_NodeInfo; 


/** \var SdnLogBuf theSdnLogBuf
 *	\brief A single instance of SdnLogBuf required by the application per node.
 */
SdnLogBuf theSdnLogBuf;


/** \var int g_iLogAuditLevel
 *	\brief A global variable that defines the SDN log level.
 *	This value can be set by setSDNLogLevel(). The default value is set to SM_INFO(2).
 */
int g_iLogAuditLevel;


static void (*g_fnCallbackSDNStatus)(int is_ready);
static int pm_qos_fd = -1;
static int ParseEnvConfig(const char* env_filename);



/** \fn SR_RET initializeSDN(char* if_name)
 *	\brief Initialize SDN node information.
 *
 *  Initialize node information which is necessary for the SdnPublisher object and SdnSubscriber object to operate.
 *  It also initializes system resources and resources related to the network interface <if_name>. 
 *  Log thread, which manages SDN log messages with lower priority, is created by this function.
 *	@param[in] if_name is the name of SDN network interface
 */
SR_RET initializeSDN(char* if_name)
{
	struct sched_param sp;
	SR_RET ret;
	pthread_t tid;
	
	if(if_name == NULL)
	{
		SDNMSG(SM_ERR, "invalid NULL parameter for initializeSDN()\n");
		
		// need to wait until debug messages are printed. 
		// uninitializeSDN() cannot be called if returned here.
		sleep(1);  		

		return SR_ERROR;
	}
	
	g_fnCallbackSDNStatus = NULL;
	
	theSdnLogBuf.initialize();
	ret = g_NodeInfo.initialize(if_name);
	if(ret != SR_OK)
	{
		SDNMSG(SM_ERR, "g_NodeInfo.initialize() failed. errno=%d.\n", ret);
		sleep(1);  		
		return ret;
	}

	/* Lock current and future allocated memory pages */
	if(mlockall(MCL_CURRENT|MCL_FUTURE) != 0)
		SDNMSG(SM_ERR, "mlockall() failed in initializeSDN(). errno=%d.\n", errno);

	/* Assign scheduling policy and priority */
	sp.sched_priority = 70;
	if (sched_setscheduler(0, SCHED_FIFO, &sp) != 0)
		SDNMSG(SM_WARN, "sched_setscheduler failed.\n"); 

	tid = theSdnLogBuf.getLogThreadId();
	if(tid != 0)
	{
		sp.sched_priority = 0;
		if (pthread_setschedparam(tid, SCHED_OTHER, &sp) != 0)
			SDNMSG(SM_WARN, "pthread_setschedparam failed.\n"); 
	}

	/* supress any of the CPU core going into deep sleep state and that may result in latency spike */
	if (pm_qos_fd < 0)  
	{
		pm_qos_fd = open("/dev/cpu_dma_latency", O_RDWR);	
		if (pm_qos_fd >= 0) 
		{  
			int target = 0;
			write(pm_qos_fd, &target, sizeof(target));	
		}	
		else
			SDNMSG(SM_WARN, "Failed to open PM QOS file: %s\n", strerror(errno)); 
	}
	
	return SR_OK;
}



/** \fn SR_RET initializeSDN(char* def_conf_file, char* user_conf_file)
 *	\brief Initialize SDN node information using configuration files generated by SDD tool.
 *
 *	Set environment variables for SDN software using configuration files generated by SDD tool, 
 *	and then call initializeSDN(char* if_name) with if_name is set to SDN_INTERFACE_NAME. 
 *	Other environment variables such as SDN_LOG_DIRECTORY and SDN_CONFIG_DIRECTORY can be set to 
 *	other values than the default value using these configuration files.
 *	@param[in] def_conf_file contains default value set by SDD tool
 *	@param[in] user_conf_file contains user modified value. NULL if not necessary.
 */
SR_RET initializeSDN(char* def_conf_file, char* user_conf_file)
{
	SR_RET ret;

	if(def_conf_file != NULL)
		ParseEnvConfig(def_conf_file);

	if(user_conf_file != NULL)
		ParseEnvConfig(user_conf_file);

	ret = initializeSDN(getenv(SDN_INTERFACE_NAME_ENVNAME));

	return ret;
}



/** \fn SR_RET terminateSDN()
 *	\brief Release system resources used by SDN software.
 *
 *  Log thread is alos terminated gracefully by this function.
 */
SR_RET terminateSDN()
{
	SR_RET ret;

	if (pm_qos_fd >= 0)  
	{
		close(pm_qos_fd);  
		pm_qos_fd = -1;
	}
	
	ret = g_NodeInfo.deinitialize();
	theSdnLogBuf.deinitialize();
	
	return ret;
}



/** \fn SR_RET setSDNLogLevel(int log_level)
 *	\brief Set log level of SDN software.
 *
 *  The SDN log messages whose level is lower than the log_level parameter are not displayed nor saved to log file.
 *  SDN log levels are defined adn arranged in ascending order as SM_LOG (lowest), SM_INFO, SM_WARN, SM_ERR, 
 *  and SM_FATAL (highest). This API can be called multiple times, and the last log level is applied.
 *  @param[in] log_level is SM_LOG, SM_INFO, SM_WARN, SM_ERR or SM_FATAL
 */
SR_RET setSDNLogLevel(int log_level)
{
	theSdnLogBuf.setLogLevel(log_level);
	return SR_OK;
}



/** \fn SR_RET setSDNStatusCallback(void (*fnCallbackSDNStatus)(int is_ready))
 *	\brief Set callback function which is called when SDN status is changed.
 *
 *  If user application sets this callback, this callback function is called whenever SDN status is changed.
 *	Only one callback function can be registered in a node.
 *	If this function is called more than once, the last callback function is set.
 *  @param[in] fnCallbackSDNStatus is callback function called when the SDN status is changed
 */
SR_RET setSDNStatusCallback(void (*fnCallbackSDNStatus)(int is_ready))
{
	g_fnCallbackSDNStatus = fnCallbackSDNStatus;
	return SR_OK;
}



/** \fn SR_RET unsetSDNStatusCallback()
 *	\brief Unset callback function which is registered by setSDNStatusCallback().
 */
SR_RET unsetSDNStatusCallback()
{
	g_fnCallbackSDNStatus = NULL;
	return SR_OK;
}



/** \fn int isSDNStatusReady()
 *	\brief Check if SDN status is ready or not
 *
 *  Return value is 1 if SDN status is ready, 0 if not ready 
 */
int isSDNStatusReady()
{
	if(g_NodeInfo.getStatusSdn() == STATUS_SDN_READY)
		return 1;
	
	return 0;
}


/** \fn pthread_t getLogThreadId()
 *	\brief Get log thread ID
 *
 *  The thread ID is used to change thread attributes such as scheduling policy and priority.
 *	Log thread is internal thread which manages log messages of SDN software. This thread should  
 *	run in lower priority than the application main thread, in which publisher and/or subscriber run, 
 *	not to impact the performance of SDN software.
 */
pthread_t getLogThreadId()
{
	return theSdnLogBuf.getLogThreadId();
}



static int ParseEnvConfig(const char* env_filename) 
{
#define	ENV_COMMENT_STR		"#"
#define	ENV_SPACE_STR		"\t "

	ifstream env_file;
	string str_line;
	string str_name;
	string str_value;
	size_t pos;
	char* name_ptr;
	char* value_ptr;

	env_file.open(env_filename, ios::in);
	if(!env_file.is_open())
	{
		SDNMSG(SM_ERR, "file[%s] open error.\n", env_filename);
		return -1;
	}

	while(!env_file.eof())
	{
		// extract contents between TAG_DBs and save it to str_topic
		getline(env_file, str_line);
		if(str_line.empty())
			continue;

		pos = str_line.find(ENV_COMMENT_STR);
		if(pos != string::npos)
		{
			str_line = str_line.substr(0, pos);
			if(str_line.empty())
				continue;
		}

		str_name.clear();
		str_value.clear();
		
		name_ptr = strtok_r((char*)str_line.c_str(), ENV_SPACE_STR, &value_ptr);
		if(name_ptr != NULL)
			str_name = name_ptr;
		if(value_ptr != NULL)
			str_value = value_ptr;

		pos = str_name.find_first_not_of(ENV_SPACE_STR);
		if(pos != string::npos)
			str_name = str_name.substr(pos);

		pos = str_name.find_first_of(ENV_SPACE_STR);
		if(pos != string::npos)
			str_name = str_name.substr(0, pos);
		
		pos = str_value.find_first_not_of(ENV_SPACE_STR);
		if(pos != string::npos)
			str_value = str_value.substr(pos);

		pos = str_value.find_first_of(ENV_SPACE_STR);
		if(pos != string::npos)
			str_value = str_value.substr(0, pos);

		if(!str_name.empty())
			setenv(str_name.c_str(), str_value.c_str(), 1);
	}
	
	env_file.close();

	return 0;
}


/** \fn SR_RET SdnNodeInfo::initialize(char* if_name)
 *	\brief Initialize SDN node information.
 *
 *  Initialize node information which is necessary for the SdnPublisher object and SdnSubscriber object to operate.
 *	@param[in] if_name is the name of SDN network interface
 */
SR_RET SdnNodeInfo::initialize(char* if_name)
{
	int ret;
	int count;
	
	if(m_statusNode_ != STATUS_NODE_INIT)
	{
		SDNMSG(SM_ERR, "already initialized.\n"); 
		return SR_ERR_ALREADY;
	}

	if(pthread_mutex_init(&m_mutexNode_, NULL) != 0)
	{
		SDNMSG(SM_ERR, "pthread_mutex_init(m_mutexNode_) failed.\n"); 
		return SR_ERROR;
	}

	if(pthread_mutex_init(&m_mutexSubList, NULL) != 0)
	{
		SDNMSG(SM_ERR, "pthread_mutex_init(m_mutexSubList) failed.\n"); 
		return SR_ERROR;
	}

	if(pthread_cond_init(&m_condSubList, NULL) != 0)
	{
		SDNMSG(SM_ERR, "pthread_mutex_init(m_mutexNode_) failed.\n"); 
		return SR_ERROR;
	}

	m_pid_ = getpid(); 

	strncpy(m_hostName_, getenv(SDN_PON_HOSTNAME_ENVNAME) ? getenv(SDN_PON_HOSTNAME_ENVNAME) : "", sizeof(m_hostName_));
	if(strlen(m_hostName_) == 0)
	{
		SDNMSG(SM_WARN, "environment variable [%s] is not defined.\n", SDN_PON_HOSTNAME_ENVNAME); 
		if(gethostname(m_hostName_, sizeof(m_hostName_)) != 0)
		{
			SDNMSG(SM_ERR, "gethostname() failed.\n"); 
			return SR_ERROR;
		}
	}
	m_hostName_[sizeof(m_hostName_)-1] = 0;

	if(getProgramName_(m_appName_, sizeof(m_appName_)) != 0)
	{
		SDNMSG(SM_ERR, "getProgramName_() failed.\n"); 
		return SR_ERROR;
	}
	
	if(getInterfaceIp_(if_name, m_sdnIpAddr_, MAX_IP_ADDR_LEN) != 0)
	{
		SDNMSG(SM_ERR, "getInterfaceIp_() failed.\n"); 
		return SR_ERROR;
	}

	// these are not cleared if threadRecv_() exit abnormally, which makes m_statusNode_ to STATUS_NODE_INIT
	m_listPubsub.clear();
	m_statusSdn_ = STATUS_SDN_NOT_READY;

	m_useMonitoringNode_ = 0;
	if(getenv(SDN_MONITORING_NODE_ENVNAME))
	{
		if(strlen(getenv(SDN_MONITORING_NODE_ENVNAME)) > 1)
			m_useMonitoringNode_ = 1;
	}

	if(m_useMonitoringNode_)
	{
		m_statusNode_ = STATUS_NODE_CONNECTING;
		m_statusNodeRsp_ = STATUS_RSP_INIT;
		
		ret = pthread_create(&m_idRecvThread_, NULL, &threadRecv_, this);
		if(ret != 0)
		{
			SDNMSG(SM_ERR, "pthread_create() failed.\n"); 
			return SR_ERROR;
		}

		count=0;
		while(count++ < TIMEOUT_NODE_CONNECTION)
		{
			if(m_statusNodeRsp_ == STATUS_RSP_ACK)
			{
				m_statusNode_ = STATUS_NODE_CONNECTED;
				break;
			}

			sleep(1);
		}

		if(m_statusNode_ != STATUS_NODE_CONNECTED)
		{
			SDNMSG(SM_ERR, "node connection failed.\n"); 
			pthread_cancel(m_idRecvThread_);
			return SR_ERROR;
		}
			
		if(registerNode_() != 0)
		{
			SDNMSG(SM_ERR, "node registration failed.\n"); 
			pthread_cancel(m_idRecvThread_);
			return SR_ERROR;
		}
	}
	else
	{
		m_statusNode_ = STATUS_NODE_REGISTERED;
		m_statusSdn_ = STATUS_SDN_READY;
	}
	
	SDNMSG(SM_INFO, "SdnNodeInfo initialized. Monitoring_Node[%d], Host[%s], SDN_IP[%s], PID[%d].\n", 
		m_useMonitoringNode_, m_hostName_, m_sdnIpAddr_, m_pid_); 

	return SR_OK;
}



/** \fn SR_RET SdnNodeInfo::deinitialize()
 *	\brief Release system resources used by SdnNodeInfo object.
 */
SR_RET SdnNodeInfo::deinitialize()
{
	if(m_statusNode_ == STATUS_NODE_INIT)
	{
		SDNMSG(SM_ERR, "not initialized.\n"); 
		return SR_ERR_NOT_INITIALIZED;
	}

	if(m_useMonitoringNode_)
	{
		unregisterNode_();
		pthread_cancel(m_idRecvThread_);
	}
	else
	{
		m_statusNode_ = STATUS_NODE_INIT;
	}

	m_listPubsub.clear();
	m_statusSdn_ = STATUS_SDN_NOT_READY;

	pthread_cond_destroy(&m_condSubList);
	pthread_mutex_destroy(&m_mutexSubList);
	pthread_mutex_destroy(&m_mutexNode_);
	
	SDNMSG(SM_INFO, "SdnNodeInfo deinitialized.\n"); 

	return SR_OK;
}



/** \fn int SdnNodeInfo::isRegistered()
 *	\brief Gets the registered status of the SDN node.
 *	When the SDN monitor node is not used, this function always returns 1.
 */
int SdnNodeInfo::isRegistered()
{
	if(m_statusNode_ == STATUS_NODE_REGISTERED)
		return 1;
	
	return 0;
}



/** \fn SR_RET SdnNodeInfo::registerPubsub(const char* topic_name, const char* topic_desc, 
 *		unsigned short topic_version, unsigned short payload_size, char is_event, char is_publisher, 
 *		char* multicast_ip_addr, unsigned short multicast_port_number)
 *	\brief Registers publisher or subscriber to the SDN monitor node.
 */
SR_RET SdnNodeInfo::registerPubsub(const char* topic_name, const char* topic_desc, 
		unsigned short topic_version, unsigned short payload_size, char is_event, char is_publisher, 
		char* multicast_ip_addr, unsigned short multicast_port_number)
{
#define BUF_SIZE	80
	KeyValue kv;
	list<KeyValue> list_kv;
	list<KeyValue> list_sub_kv;
	char* p_send_msg;
	ConstructMessage construct_message;
	int ret;
	char buf[BUF_SIZE];
	PubsubInfo pubsub_info;
	list<PubsubInfo>::iterator iter;

	pubsub_info.m_isPublisher = is_publisher;
	pubsub_info.m_nameTopic = topic_name;
	pubsub_info.m_descTopic = topic_desc;
	pubsub_info.m_versionTopic = topic_version;
	pubsub_info.m_sizePayload = payload_size;
	pubsub_info.m_isEvent = is_event;
	pubsub_info.m_mcastIpAddr = multicast_ip_addr;
	pubsub_info.m_mcastPort = multicast_port_number;
	pubsub_info.m_statusPubsub = STATUS_PUBSUB_INIT;

	LOCK(m_mutexNode_);

	m_listPubsub.push_front(pubsub_info);
	iter = m_listPubsub.begin();

	UNLOCK(m_mutexNode_);

	if(m_useMonitoringNode_)
	{
		list_kv.clear();
		if(is_publisher)
			kv.setValue(KEY_CMD, VAL_CMD__PUB_REG);
		else
			kv.setValue(KEY_CMD, VAL_CMD__SUB_REG);
		list_kv.push_back(kv);

		list_sub_kv.clear();
		kv.setValue(KEY_META_TOPICNAME, topic_name);
		list_sub_kv.push_back(kv);
		kv.setValue(KEY_META_TOPICDESC, topic_desc);
		list_sub_kv.push_back(kv);
		snprintf(buf, BUF_SIZE, "%d", topic_version);
		kv.setValue(KEY_META_TOPICVER, (const char*)buf);
		list_sub_kv.push_back(kv);
		snprintf(buf, BUF_SIZE, "%d", payload_size);
		kv.setValue(KEY_META_PAYLOADSIZE, (const char*)buf);
		list_sub_kv.push_back(kv);
		kv.setValue(KEY_META_ISEVENT, (const char*)(is_event ? VAL_META_ISEVENT__TRUE : VAL_META_ISEVENT__FALSE));
		list_sub_kv.push_back(kv);
		kv.setList(KEY_META, &list_sub_kv);
		list_kv.push_back(kv);

		p_send_msg = construct_message.construct(VALUE_MESSAGE_GROUP_REGISTER, &list_kv);
		if(p_send_msg == NULL)
		{
			SDNMSG(SM_ERR, "construct() returned NULL.\n");

			LOCK(m_mutexNode_);
			m_listPubsub.erase(iter);
			UNLOCK(m_mutexNode_);

			return SR_ERROR;
		}

		(*iter).m_statusPubsub = STATUS_PUBSUB_REGISTERING;
		(*iter).m_statusPubsubRsp = STATUS_RSP_INIT;
		sendNodeMessage_(p_send_msg);
		waitRsp_(&((*iter).m_statusPubsubRsp));

		if((*iter).m_statusPubsubRsp != STATUS_RSP_ACK)
		{
			SDNMSG(SM_ERR, "failed to get STATUS_PUBSUB_REGISTERED\n"); 

			LOCK(m_mutexNode_);
			m_listPubsub.erase(iter);
			UNLOCK(m_mutexNode_);

			return SR_ERROR;
		}
	}
	else
	{
		// Without this delay, first receive is failed in the subscriber. 
		// (Why??? Is delay necessary between creating socket and receiving data with this socket???)
		// When using monitoring node, this delay is added by sending SDN_READY status after 1 second.
		if(!is_publisher)
			sleep(1);	
	}

	(*iter).m_statusPubsub = STATUS_PUBSUB_REGISTERED;
	
	return SR_OK;
}



/** \fn SR_RET SdnNodeInfo::unregisterPubsub(const char* topic_name, char is_publisher)
 *	\brief Unregisters publisher or subscriber from the SDN monitor node.
 *
 *	@param[in] topic_name is the topic name of publisher or subscriber
 *	@param[in] is_publisher indicates if it is publisher(1) or subscriber(0)
 */
SR_RET SdnNodeInfo::unregisterPubsub(const char* topic_name, char is_publisher)
{
	KeyValue kv;
	list<KeyValue> list_kv;
	char* p_send_msg;
	ConstructMessage construct_message;
	int ret;
	PubsubInfo pubsub_info;
	list<PubsubInfo>::iterator iter;
	int b_found;
	SR_RET sr_ret = SR_OK;

	LOCK(m_mutexNode_);

	b_found = 0;
	for(iter = m_listPubsub.begin(); iter != m_listPubsub.end(); iter++)
	{
		if(((*iter).m_nameTopic.compare(topic_name) == 0)
			&& ((*iter).m_isPublisher == is_publisher)
			&& ((*iter).m_statusPubsub == STATUS_PUBSUB_REGISTERED))
		{
			b_found = 1;
			break;
		}
	}

	UNLOCK(m_mutexNode_);

	if(!b_found)
	{
		SDNMSG(SM_ERR, "failed to find corresponding pubsub in the list\n");
		return SR_ERROR;
	}

	if(m_useMonitoringNode_)
	{
		list_kv.clear();
		if(is_publisher)
			kv.setValue(KEY_CMD, VAL_CMD__PUB_UNREG);
		else
			kv.setValue(KEY_CMD, VAL_CMD__SUB_UNREG);
		list_kv.push_back(kv);

		kv.setValue(KEY_TOPICNAME, topic_name);
		list_kv.push_back(kv);

		p_send_msg = construct_message.construct(VALUE_MESSAGE_GROUP_REGISTER, &list_kv);
		if(p_send_msg == NULL)
		{
			SDNMSG(SM_ERR, "construct() returned NULL.\n");

			LOCK(m_mutexNode_);
			m_listPubsub.erase(iter);
			UNLOCK(m_mutexNode_);

			return SR_ERROR;
		}

		(*iter).m_statusPubsub = STATUS_PUBSUB_UNREGISTERING;
		(*iter).m_statusPubsubRsp = STATUS_RSP_INIT;
		sendNodeMessage_(p_send_msg);
		waitRsp_(&((*iter).m_statusPubsubRsp));

		if((*iter).m_statusPubsubRsp != STATUS_RSP_ACK)
		{
			SDNMSG(SM_ERR, "failed to get STATUS_PUBSUB_UNREGISTERED\n"); 

			LOCK(m_mutexNode_);
			m_listPubsub.erase(iter);
			UNLOCK(m_mutexNode_);

			return SR_ERROR;
		}
	}
	
	LOCK(m_mutexNode_);
	m_listPubsub.erase(iter);
	UNLOCK(m_mutexNode_);

	return SR_OK;
}



/** \fn STATUS_SDN SdnNodeInfo::getStatusSdn()
 *	\brief Gets the SDN network status.
 *	SDN network status becomes READY when all the topics and their publisher and subscribers are registered.
 *	When the SDN monitor node is not used, this function always returns STATUS_SDN_READY.
 */
STATUS_SDN SdnNodeInfo::getStatusSdn()
{
	return m_statusSdn_;
}



/** \fn SR_RET SdnNodeInfo::getMulticastAddress(const char* topic_name, char* multicast_ip, unsigned short* multicast_port)
 *  \brief Get multicast IP address and port from a file 
 *	\todo At present map is defined into a file topic_multicast_map.dat but later implementation will replace it by IPAM or LDAP.
 */
SR_RET SdnNodeInfo::getMulticastAddress(const char* topic_name, char* multicast_ip, unsigned short* multicast_port)
{
	int found=0;
	unsigned short lport; 
	string line;
	string file_name;
	ifstream mapfile;
	char* cur_ptr;
	char* next_ptr;
	char* tmp;

	file_name = getenv(SDN_CONFIG_DIRECTORY_ENVNAME) ? getenv(SDN_CONFIG_DIRECTORY_ENVNAME) : "";
	if(strlen(file_name.c_str()) == 0)
		file_name = SDN_CONFIG_DIRECTORY_DEFAULT;
	
	file_name += "/topic_multicast_map.dat";
	mapfile.open(file_name.c_str(), ios::in);

	if (mapfile.is_open())
	{
		while (getline(mapfile, line)) {
			if (line.empty())
				break;

			cur_ptr = (char*)line.c_str();
			tmp = strtok_r(cur_ptr, "'\t'", &next_ptr);
			if(tmp != NULL)
			{
				if(strcmp(topic_name, tmp) == 0)
				{
					tmp = strtok_r(NULL, "'\t'", &next_ptr);
					if(tmp != NULL)
					{
						strcpy(multicast_ip, tmp);

						tmp = strtok_r(NULL, "'\n'", &next_ptr);
						if(tmp != NULL)
						{
							*multicast_port=(unsigned short)atoi(tmp);
							found=1;
							break;
						}
					}
				}
			}
		}

		mapfile.close();
		if (found==0)
		{
			SDNMSG(SM_ERR," topic_name is not found in map file\n");
			return SR_ERROR;
		}
		if (*multicast_port==0)
		{
			SDNMSG(SM_ERR," Publisher; Error in parsing map file\n");
			return SR_ERROR;
		}
	}
	else
	{
		SDNMSG(SM_ERR,"Unable to open multicast map file\n");
		return SR_ERROR;
	}
	
	return SR_OK;
}



/** \fn char* SdnNodeInfo::getHostName()
 *	\brief Gets the host name of the controller.
 */
char* SdnNodeInfo::getHostName()
{
	return m_hostName_;
}



/** \fn char* SdnNodeInfo::getAppName()
 *	\brief Gets the application name.
 */
char* SdnNodeInfo::getAppName()
{
	return m_appName_;
}



/** \fn char* SdnNodeInfo::getSdnIpAddr()
 *	\brief Gets the IP address which is assigned to the SDN network interface card.
 */
char* SdnNodeInfo::getSdnIpAddr()
{
	return m_sdnIpAddr_;
}



/** \fn int SdnNodeInfo::getPeerInfo(const char* topic_name, int is_publisher, int is_event, std::list<PeerInfo>& peer_info_list)
 *	\brief Gets the list of PeerInfo which matches to the topic_name, is_publisher, and is_event.
 *	peer_info_list is valid only when the return value is 0.
 *	@param[in] topic_name is the topic name of publisher or subscriber
 *	@param[in] is_publisher indicates if it is publisher(1) or subscriber(0)
 *	@param[in] is_event indicates if it is event topic(1) or normal topic(0)
 *	@param[out] peer_info_list is the list of PeerInfo which matches to to topic_name, is_publisher, and is_event.
 */
int SdnNodeInfo::getPeerInfo(const char* topic_name, int is_publisher, int is_event, std::list<PeerInfo>& peer_info_list)
{
	int is_found = 0;

	LOCK(m_mutexNode_);
	
	for(list<PubsubInfo>::iterator iter = m_listPubsub.begin(); iter != m_listPubsub.end(); iter++)
	{
		if(((*iter).m_nameTopic.compare(topic_name) == 0)
			&& ((*iter).m_isPublisher == is_publisher)
			&& ((*iter).m_isEvent == is_event)
			&& (((*iter).m_statusPubsub == STATUS_PUBSUB_REGISTERED)
				|| (((*iter).m_statusPubsub == STATUS_PUBSUB_REGISTERING)
					&& ((*iter).m_statusPubsubRsp == STATUS_RSP_ACK))))
		{
			is_found = 1;
			peer_info_list = (*iter).m_listPeer;
			break;
		}
	}
	
	UNLOCK(m_mutexNode_);

	if(!is_found)
		return -1;

	return 0;
}



//////////////////////////////////////////////////////////////////////////////////
// Private Functions

int SdnNodeInfo::getInterfaceIp_(char* if_name, char* ip_addr, int ip_addr_len) 
{ 
	int s; 
	struct ifconf ifconf; 
	struct ifreq ifr[100]; 
	int ifs; 
	int i; 
	char ip[INET_ADDRSTRLEN]; 
	struct sockaddr_in* s_in; 

	s = socket(AF_INET, SOCK_DGRAM, 0); 
	if (s < 0) 
	{ 
		SDNMSG(SM_ERR, "socket() failed.\n"); 
		return 1; 
	} 

	ifconf.ifc_buf = (char*)ifr; 
	ifconf.ifc_len = sizeof ifr; 

	if (ioctl(s, SIOCGIFCONF, &ifconf) == -1) 
	{ 
		SDNMSG(SM_ERR, "ioctl() failed.\n"); 
		close(s); 
		return 2; 
	} 

	ifs = ifconf.ifc_len / sizeof(ifr[0]); 
	SDNMSG(SM_LOG, "interfaces = %d\n", ifs); 
	
	for (i = 0; i < ifs; i++) 
	{ 
		s_in = (struct sockaddr_in*)&ifr[i].ifr_addr; 

		if(strcmp(if_name, ifr[i].ifr_name) != 0)
			continue;
			
		if (!inet_ntop(AF_INET, &s_in->sin_addr, ip, sizeof(ip))) 
		{ 
			SDNMSG(SM_ERR, "inet_ntop() failed.\n"); 
			close(s); 
			return 3; 
		} 

		break;
	}

	close(s); 

	if(i >= ifs)
	{
		SDNMSG(SM_ERR, "no matched interface for [%s]\n", if_name); 
		return 4;
	}

	SDNMSG(SM_LOG, "matched: [%s] => [%s]\n", if_name, ip);

	if(strlen(ip) >= ip_addr_len)
	{
		SDNMSG(SM_LOG, "matched: [%s] => [%s]\n", if_name, ip);
	}
		
	strncpy(ip_addr, ip, ip_addr_len-1);

	return 0;
}



int SdnNodeInfo::getProgramName_(char* buf, int buf_len)
{
	int found=0;
	string line;
	ifstream status_file;
	char* cur_ptr;
	char* next_ptr;
	char* tmp;
	char* app_name;

	app_name = getenv(SDN_APP_NAME_ENVNAME) ? getenv(SDN_APP_NAME_ENVNAME) : (char*)"";
	if(strlen(app_name) > 0)
	{
		strncpy(buf, app_name, buf_len-1);
		buf[buf_len-1] = 0;
		found = 1;
	}
	else
	{
		status_file.open("/proc/self/status", ios::in);

		if (status_file.is_open())
		{
			while (getline(status_file, line)) {
				if (line.empty())
					break;

				cur_ptr = (char*)line.c_str();
				tmp = strtok_r(cur_ptr, "'\t'", &next_ptr);
				if(tmp != NULL)
				{
					if(strcmp("Name:", tmp) == 0)
					{
						if(next_ptr != NULL)
						{
							strncpy(buf, next_ptr, buf_len-1);
							buf[buf_len-1] = 0;
							found = 1;
							break;
						}
					}
				}
			}

			status_file.close();
		}
	}

	if (found == 0)
		return 1;

	return 0;
}



int SdnNodeInfo::registerNode_()
{
	KeyValue kv;
	list<KeyValue> list_kv;
	list<KeyValue> list_sub_kv;
	char* p_send_msg;
	ConstructMessage construct_message;
	int ret;
	
	list_kv.clear();
	kv.setValue(KEY_CMD, VAL_CMD__NODE_REG);
	list_kv.push_back(kv);

	list_sub_kv.clear();
	kv.setValue(KEY_PARAM_HOSTNAME, (const char*)m_hostName_);
	list_sub_kv.push_back(kv);
	kv.setValue(KEY_PARAM_APPNAME, (const char*)m_appName_);
	list_sub_kv.push_back(kv);
	kv.setValue(KEY_PARAM_IP, (const char*)m_sdnIpAddr_);
	list_sub_kv.push_back(kv);

	kv.setList(KEY_PARAM, &list_sub_kv);
	list_kv.push_back(kv);


	p_send_msg = construct_message.construct(VALUE_MESSAGE_GROUP_REGISTER, &list_kv);
	if(p_send_msg == NULL)
	{
		SDNMSG(SM_ERR, "construct() returned NULL.\n");
		return 1;
	}

	m_statusNode_ = STATUS_NODE_REGISTERING;
	m_statusNodeRsp_ = STATUS_RSP_INIT;
	sendNodeMessage_(p_send_msg);
	waitRsp_(&m_statusNodeRsp_);

	if(m_statusNodeRsp_ != STATUS_RSP_ACK)
	{
		SDNMSG(SM_ERR, "failed to get STATUS_NODE_REGISTERED\n"); 

		m_statusNode_ = STATUS_NODE_INIT;
		return 1;
	}
	
	m_statusNode_ = STATUS_NODE_REGISTERED;
	
	return 0;
}



int SdnNodeInfo::unregisterNode_()
{
	int count;

	m_statusNode_ = STATUS_NODE_UNREGISTERING;
	m_statusNodeRsp_ = STATUS_RSP_INIT;
	sendSimpleMessage_(KEY_CMD, VAL_CMD__NODE_UNREG);
	waitRsp_(&m_statusNodeRsp_);
	
	if(m_statusNodeRsp_ != STATUS_RSP_ACK)
	{
		SDNMSG(SM_ERR, "failed to get STATUS_NODE_UNREGISTERED\n"); 

		m_statusNode_ = STATUS_NODE_UNREGISTERED;
		return 1;
	}
	
	m_statusNode_ = STATUS_NODE_UNREGISTERED;

	return 0;
}



int SdnNodeInfo::sendNodeMessage_(char* p_send_message)
{
	int ret;

	if(m_sockMonitoringNode_ < 0)
	{
		SDNMSG(SM_ERR, "invalid socket for monitoing node connection\n");
		return -1;
	}
	
	SDNMSG(SM_TEST, "[SEND(%d)]\n%s", strlen(p_send_message), p_send_message);

	ret = send(m_sockMonitoringNode_, p_send_message, strlen(p_send_message), 0);
	if(ret != strlen(p_send_message))
	{
		SDNMSG(SM_ERR, "send(%d) returned %d.\n", strlen(p_send_message), ret);
		return -1;
	}

	return 0;
}



int SdnNodeInfo::sendSimpleMessage_(const char* p_key, const char* p_value)
{
	KeyValue kv;
	list<KeyValue> list_kv;
	char* p_send_msg;
	ConstructMessage construct_message;
	int ret;

	list_kv.clear();
	kv.setValue(p_key, p_value);
	list_kv.push_back(kv);
	p_send_msg = construct_message.construct(VALUE_MESSAGE_GROUP_REGISTER, &list_kv);
	
	ret = sendNodeMessage_(p_send_msg);

	return ret;
}



int SdnNodeInfo::waitRsp_(STATUS_RSP* p_rsp)
{
	int count=0;
	
	while(count++ < TIMEOUT_NODE_MESSAGE)
	{
		if(*p_rsp != STATUS_RSP_INIT)
		{
			return 0;
		}
	
		sleep(1);
	}

	return -1;
}



void* SdnNodeInfo::threadRecv_(void* p_param)
{
#define	MAX_RECV_BUF_SIZE			1500
	struct sockaddr_in addr;
	string monitor_node_ip;
	int monitor_node_port;
	string tmp_str;
	int ret;
	char recv_buf[MAX_RECV_BUF_SIZE];
	SdnNodeInfo* p_node_info = (SdnNodeInfo*)p_param;
	struct sched_param param; 
	pthread_attr_t tattr;
	char* p_next;
	
	if(p_node_info == NULL)
	{
		SDNMSG(SM_ERR, "invalid null parameter\n");
		return (void*)1;
	}

	p_node_info->m_sockMonitoringNode_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(p_node_info->m_sockMonitoringNode_ < 0)
	{
		SDNMSG(SM_ERR, "socket() error\n");
		return (void*)1;
	}

	// monitor_node_ip can be hostname
	monitor_node_ip = getenv(SDN_MONITORING_NODE_ENVNAME) ? getenv(SDN_MONITORING_NODE_ENVNAME) : "";
	if(monitor_node_ip.size() <= 1)
		return (void*)1;

	monitor_node_ip = strtok_r((char*)monitor_node_ip.c_str(), ":", &p_next);
	if(p_next == NULL)
		monitor_node_port = DEFAULT_SDN_MONITOR_SERVER_PORT_REG;
	else if(strlen(p_next) == 0)
		monitor_node_port = DEFAULT_SDN_MONITOR_SERVER_PORT_REG;
	else
		monitor_node_port = atoi(p_next);

	memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_port = htons(monitor_node_port);
	addr.sin_addr.s_addr = inet_addr(monitor_node_ip.c_str());
	if ((int)addr.sin_addr.s_addr == -1)
	{
		struct hostent* phe;
		if ((phe = gethostbyname(monitor_node_ip.c_str())) == NULL)
		{
			SDNMSG(SM_ERR, "gethostbyname() error\n");
			close(p_node_info->m_sockMonitoringNode_);
			p_node_info->m_sockMonitoringNode_ = -1;
			return (void*)1;
		}
	
		memcpy((char*) &addr.sin_addr, phe->h_addr, phe->h_length);
	}

	pthread_cleanup_push(p_node_info->cleanupThreadRecv_, p_node_info);

	pthread_attr_init(&tattr);

	param.sched_priority = 0;
	ret = pthread_attr_setschedparam (&tattr, &param);
	if(ret != 0)
		SDNMSG(SM_WARN, "pthread_attr_setschedparam() failed.\n");
	
	pthread_attr_destroy(&tattr);

	ret = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
	if (ret != 0)
		SDNMSG(SM_WARN,"pthread_setcancelstate(PTHREAD_CANCEL_ENABLE) failed.\n");

	// connect to monitoring node
	if(connect(p_node_info->m_sockMonitoringNode_, (struct sockaddr*)&addr, sizeof(addr)) < 0)
	{
		SDNMSG(SM_ERR, "connect(fd = %d, ip = %s, port = %d) fail. errno=%d\n", 
			p_node_info->m_sockMonitoringNode_, monitor_node_ip.c_str(), monitor_node_port, errno);
		close(p_node_info->m_sockMonitoringNode_);
		p_node_info->m_statusNode_ = STATUS_NODE_INIT;
		return (void*)1;
	}
	
	p_node_info->m_statusNodeRsp_ = STATUS_RSP_ACK;

	// recv loop
	while(1)
	{
		ret = recv(p_node_info->m_sockMonitoringNode_, recv_buf, MAX_RECV_BUF_SIZE, 0);
		if(ret <= 0)	// socket closed or error
		{
			if((errno == EINTR) || (errno == EAGAIN))
			{
				SDNMSG(SM_WARN, "recv() returned errno %d\n", errno);
				continue;
			}

			SDNMSG(SM_ERR,"recv() returned %d\n", ret);
			break;
		}
		else
		{
			char* cur_ptr;
			char* next_ptr;
			char* end_ptr;
			
			SDNMSG(SM_TEST, "[RECV(%d)]\n%s", strlen(recv_buf), recv_buf);
			
			cur_ptr = recv_buf;
			end_ptr = recv_buf + strlen(recv_buf);
			
			while(cur_ptr < end_ptr)
			{
				next_ptr = strstr(cur_ptr, DELIM_KEY_END);
				if(next_ptr == NULL)
					break;
			
				if(next_ptr + 1 < end_ptr)
				{
					*(next_ptr + 1) = 0;
					// Parse and process message
					p_node_info->processNodeMessage_(cur_ptr);
				}
			
				cur_ptr = next_ptr + 2;
			}
		}
	}

	pthread_cleanup_pop(1);

	return (void*)0;
}



void SdnNodeInfo::cleanupThreadRecv_(void* p_param)
{
	SdnNodeInfo* p_node_info = (SdnNodeInfo*)p_param;

	if(p_node_info == NULL)
	{
		SDNMSG(SM_ERR, "invalid null parameter\n");
		return;
	}

	p_node_info->m_statusNode_ = STATUS_NODE_INIT;

	close(p_node_info->m_sockMonitoringNode_);
	p_node_info->m_sockMonitoringNode_ = -1;
	
	return;
}



int SdnNodeInfo::processNodeMessage_(char* p_buf)
{
	ParseMessage parse_message;

	KeyValue* p_kv;
	KeyValue* p_kv_command;
	KeyValue kv;
	list<KeyValue> list_kv;

	char* cur_ptr;
	char* next_ptr;
	int version_major;
	int version_minor;

	list<PubsubInfo>::iterator iter;
	int b_found;
	KeyValue* p_kv_topicname;


	parse_message.parse(p_buf);

	// check protocol version
	p_kv = parse_message.getKey(NULL, KEY_PROTOCOL_VERSION);
	if(p_kv == NULL)
	{
		SDNMSG(SM_ERR, "no KEY_PROTOCOL_VERSION in the message.\n");
		return -1;
	}

	cur_ptr = strtok_r((char*)p_kv->m_strValue.c_str(), ".", &next_ptr);
	version_major = (cur_ptr == NULL) ? 0 : atoi(cur_ptr);	
	version_minor = (next_ptr == NULL) ? 0 : atoi(next_ptr);
	if(version_major != VALUE_PROTOCOL_VERSION_MAJOR)
	{
		SDNMSG(SM_ERR, "protocol version(%d.%d) does not consistent with current version(%d.%d)\n",
			version_major, version_minor, VALUE_PROTOCOL_VERSION_MAJOR, VALUE_PROTOCOL_VERSION_MINOR);
		return -1;
	}

	// check if message is for register protocol
	p_kv = parse_message.getKey(NULL, KEY_MESSAGE_GROUP);
	if(p_kv == NULL)
	{
		SDNMSG(SM_ERR, "no KEY_MESSAGE_GROUP in the message.\n");
		return -1;
	}

	if(p_kv->m_strValue.compare(VALUE_MESSAGE_GROUP_REGISTER) != 0)
	{
		SDNMSG(SM_ERR, "KEY_MESSAGE_GROUP is not VALUE_MESSAGE_GROUP_REGISTER.\n");
		return -1;
	}

	// process register message
	p_kv_command = parse_message.getKey(NULL, KEY_CMD);
	if(p_kv_command == NULL)
	{
		SDNMSG(SM_ERR, "KEY_CMD does not exist in the register message.\n");
		return -1;
	}

	SDNMSG(SM_LOG, "[%s] received from SDN_MONITOR\n", p_kv_command->m_strValue.c_str());

	if((p_kv_command->m_strValue.compare(VAL_CMD__NODE_REG_ACK) == 0)
		|| (p_kv_command->m_strValue.compare(VAL_CMD__NODE_REG_NACK) == 0))
	{
		if(m_statusNode_ != STATUS_NODE_REGISTERING)
		{
			SDNMSG(SM_ERR, "REG_ACK(NACK) in invalid state(%d)\n", m_statusNode_);
			return -1;
		}
		
		if(p_kv_command->m_strValue.compare(VAL_CMD__NODE_REG_ACK) == 0)
		{
			m_statusNodeRsp_ = STATUS_RSP_ACK;
		}
		else
		{
			m_statusNodeRsp_ = STATUS_RSP_NACK;
		}
	}
	else if((p_kv_command->m_strValue.compare(VAL_CMD__NODE_UNREG_ACK) == 0)
		|| (p_kv_command->m_strValue.compare(VAL_CMD__NODE_UNREG_NACK) == 0))
	{
		if(m_statusNode_ != STATUS_NODE_UNREGISTERING)
		{
			SDNMSG(SM_ERR, "UNREG_ACK(NACK) in invalid state(%d)\n", m_statusNode_);
			return -1;
		}
		
		if(p_kv_command->m_strValue.compare(VAL_CMD__NODE_UNREG_ACK) == 0)
			m_statusNodeRsp_ = STATUS_RSP_ACK;
		else
			m_statusNodeRsp_ = STATUS_RSP_NACK;
	}
	else if((p_kv_command->m_strValue.compare(VAL_CMD__PUB_REG_ACK) == 0)
		|| (p_kv_command->m_strValue.compare(VAL_CMD__PUB_REG_NACK) == 0))
	{
		p_kv_topicname = parse_message.getKey(NULL, KEY_TOPICNAME);
		if(p_kv_topicname == NULL)
		{
			SDNMSG(SM_ERR, "KEY_TOPICNAME does not exist in the publisher register_ack message.\n");
			return -1;
		}
		
		b_found = 0;

		LOCK(m_mutexNode_);
		
		for(iter = m_listPubsub.begin(); iter != m_listPubsub.end(); iter++)
		{
			if(((*iter).m_nameTopic.compare(p_kv_topicname->m_strValue) == 0)
				&& ((*iter).m_isPublisher == 1)
				&& ((*iter).m_statusPubsub == STATUS_PUBSUB_REGISTERING)
				&& ((*iter).m_statusPubsubRsp == STATUS_RSP_INIT))
			{
				b_found = 1;
				break;
			}
		}

		UNLOCK(m_mutexNode_);

		if(!b_found)
		{
			SDNMSG(SM_ERR, "Failed to find pubsub info for PUB_REG_ACK(NACK)\n");
			return -1;
		}
		
		if(p_kv_command->m_strValue.compare(VAL_CMD__PUB_REG_ACK) == 0)
			(*iter).m_statusPubsubRsp  = STATUS_RSP_ACK;
		else
			(*iter).m_statusPubsubRsp  = STATUS_RSP_NACK;
	}
	else if((p_kv_command->m_strValue.compare(VAL_CMD__PUB_UNREG_ACK) == 0)
		|| (p_kv_command->m_strValue.compare(VAL_CMD__PUB_UNREG_NACK) == 0))
	{
		p_kv_topicname = parse_message.getKey(NULL, KEY_TOPICNAME);
		if(p_kv_topicname == NULL)
		{
			SDNMSG(SM_ERR, "KEY_TOPICNAME does not exist in the publisher unregister_ack message.\n");
			return -1;
		}
		
		b_found = 0;

		LOCK(m_mutexNode_);
		
		for(iter = m_listPubsub.begin(); iter != m_listPubsub.end(); iter++)
		{
			if(((*iter).m_nameTopic.compare(p_kv_topicname->m_strValue) == 0)
				&& ((*iter).m_isPublisher == 1)
				&& ((*iter).m_statusPubsub == STATUS_PUBSUB_UNREGISTERING)
				&& ((*iter).m_statusPubsubRsp == STATUS_RSP_INIT))
			{
				b_found = 1;
				break;
			}
		}

		UNLOCK(m_mutexNode_);

		if(!b_found)
		{
			SDNMSG(SM_ERR, "Failed to find pubsub info for PUB_UNREG_ACK(NACK)\n");
			return -1;
		}
		
		if(p_kv_command->m_strValue.compare(VAL_CMD__PUB_UNREG_ACK) == 0)
			(*iter).m_statusPubsubRsp  = STATUS_RSP_ACK;
		else
			(*iter).m_statusPubsubRsp  = STATUS_RSP_NACK;
	}
	else if((p_kv_command->m_strValue.compare(VAL_CMD__SUB_REG_ACK) == 0)
		|| (p_kv_command->m_strValue.compare(VAL_CMD__SUB_REG_NACK) == 0))
	{
		p_kv_topicname = parse_message.getKey(NULL, KEY_TOPICNAME);
		if(p_kv_topicname == NULL)
		{
			SDNMSG(SM_ERR, "KEY_TOPICNAME does not exist in the subscriber register_ack message.\n");
			return -1;
		}
		
		b_found = 0;

		LOCK(m_mutexNode_);
		
		for(iter = m_listPubsub.begin(); iter != m_listPubsub.end(); iter++)
		{
			if(((*iter).m_nameTopic.compare(p_kv_topicname->m_strValue) == 0)
				&& ((*iter).m_isPublisher == 0)
				&& ((*iter).m_statusPubsub == STATUS_PUBSUB_REGISTERING)
				&& ((*iter).m_statusPubsubRsp == STATUS_RSP_INIT))
			{
				b_found = 1;
				break;
			}
		}

		UNLOCK(m_mutexNode_);

		if(!b_found)
		{
			SDNMSG(SM_ERR, "Failed to find pubsub info for SUB_REG_ACK(NACK)\n");
			return -1;
		}
		
		if(p_kv_command->m_strValue.compare(VAL_CMD__SUB_REG_ACK) == 0)
			(*iter).m_statusPubsubRsp  = STATUS_RSP_ACK;
		else
			(*iter).m_statusPubsubRsp  = STATUS_RSP_NACK;
	}
	else if((p_kv_command->m_strValue.compare(VAL_CMD__SUB_UNREG_ACK) == 0)
		|| (p_kv_command->m_strValue.compare(VAL_CMD__SUB_UNREG_NACK) == 0))
	{
		p_kv_topicname = parse_message.getKey(NULL, KEY_TOPICNAME);
		if(p_kv_topicname == NULL)
		{
			SDNMSG(SM_ERR, "KEY_TOPICNAME does not exist in the subscriber unregister_ack message.\n");
			return -1;
		}
		
		b_found = 0;

		LOCK(m_mutexNode_);
		
		for(iter = m_listPubsub.begin(); iter != m_listPubsub.end(); iter++)
		{
			if(((*iter).m_nameTopic.compare(p_kv_topicname->m_strValue) == 0)
				&& ((*iter).m_isPublisher == 0)
				&& ((*iter).m_statusPubsub == STATUS_PUBSUB_UNREGISTERING)
				&& ((*iter).m_statusPubsubRsp == STATUS_RSP_INIT))
			{
				b_found = 1;
				break;
			}
		}

		UNLOCK(m_mutexNode_);

		if(!b_found)
		{
			SDNMSG(SM_ERR, "Failed to find pubsub info for SUB_UNREG_ACK(NACK)\n");
			return -1;
		}
		
		if(p_kv_command->m_strValue.compare(VAL_CMD__SUB_UNREG_ACK) == 0)
			(*iter).m_statusPubsubRsp  = STATUS_RSP_ACK;
		else
			(*iter).m_statusPubsubRsp  = STATUS_RSP_NACK;
	}
	else if(p_kv_command->m_strValue.compare(VAL_CMD__NOTIFY_SDN_STATUS) == 0)
	{
		KeyValue* p_kv_sdnstatus;
		STATUS_SDN new_status;
		
		p_kv_sdnstatus = parse_message.getKey(NULL, KEY_SDNSTATUS);
		if(p_kv_sdnstatus == NULL)
		{
			SDNMSG(SM_ERR, "KEY_SDNSTATUS does not exist in the notify_status message.\n");
			return -1;
		}

		if(p_kv_sdnstatus->m_strValue.compare(VAL_STATUS__READY) == 0)
			new_status = STATUS_SDN_READY;
		else
			new_status = STATUS_SDN_NOT_READY;

		if(new_status != m_statusSdn_)
		{
			m_statusSdn_ = new_status;

			if(g_fnCallbackSDNStatus != NULL)
				g_fnCallbackSDNStatus(m_statusSdn_);
		}
	}
	else if(p_kv_command->m_strValue.compare(VAL_CMD__NOTIFY_TOPIC_STATUS) == 0)
	{
		// nothing to do 
		;
	}
	else if(p_kv_command->m_strValue.compare(VAL_CMD__NOTIFY_PUB_INFO) == 0)
	{
		PeerInfo peer_info;
		KeyValue* p_kv_param;
		KeyValue* p_kv_hostname;
		KeyValue* p_kv_appname;
		KeyValue* p_kv_ipaddr;
		
		p_kv_topicname = parse_message.getKey(NULL, KEY_TOPICNAME);
		if(p_kv_topicname == NULL)
		{
			SDNMSG(SM_ERR, "KEY_TOPICNAME does not exist in the notify_pub_info message.\n");
			return -1;
		}

		p_kv_param = parse_message.getKey(NULL, KEY_PARAM);
		if(p_kv_param == NULL)
		{
			SDNMSG(SM_ERR, "KEY_PARAM does not exist in the notify_pub_info message.\n");
			return -1;
		}

		p_kv_hostname = parse_message.getKey(&p_kv_param->m_listKeyValue, KEY_PARAM_HOSTNAME);
		p_kv_appname = parse_message.getKey(&p_kv_param->m_listKeyValue, KEY_PARAM_APPNAME);
		p_kv_ipaddr = parse_message.getKey(&p_kv_param->m_listKeyValue, KEY_PARAM_IP);
		if((p_kv_hostname == NULL) || (p_kv_appname == NULL) || (p_kv_ipaddr == NULL))
		{
			SDNMSG(SM_ERR, "KEY_PARAM is not complete in the notify_pub_info message.\n");
			return -1;
		}

		peer_info.m_nameHost = p_kv_hostname->m_strValue;
		peer_info.m_nameApp = p_kv_appname->m_strValue;
		peer_info.m_addrIp = p_kv_ipaddr->m_strValue;
		
		b_found = 0;

		LOCK(m_mutexNode_);
		
		for(iter = m_listPubsub.begin(); iter != m_listPubsub.end(); iter++)
		{
			if(((*iter).m_nameTopic.compare(p_kv_topicname->m_strValue) == 0)
				&& ((*iter).m_isPublisher == 0)
				&& ((*iter).m_isEvent == 1)
				&& (((*iter).m_statusPubsub == STATUS_PUBSUB_REGISTERED)
					|| (((*iter).m_statusPubsub == STATUS_PUBSUB_REGISTERING)
						&& ((*iter).m_statusPubsubRsp == STATUS_RSP_ACK))))
			{
				b_found = 1;

				(*iter).m_listPeer.clear();
				(*iter).m_listPeer.push_back(peer_info);
			}
		}

		UNLOCK(m_mutexNode_);

		// wake-up subscribers socket setup thread if any
		LOCK(m_mutexSubList);
		pthread_cond_broadcast(&m_condSubList);
		UNLOCK(m_mutexSubList);

		if(!b_found)
		{
			SDNMSG(SM_ERR, "Failed to find subscriber for notify_pub_info\n");
			return -1;
		}
	}
	else if(p_kv_command->m_strValue.compare(VAL_CMD__NOTIFY_SUB_LIST) == 0)
	{
		PeerInfo peer_info;
		KeyValue* p_kv_sublist;
		KeyValue* p_kv_sublist_sub;
		KeyValue* p_kv_hostname;
		KeyValue* p_kv_appname;
		KeyValue* p_kv_ipaddr;
		list<KeyValue>::iterator iter_key_value;
		
		p_kv_topicname = parse_message.getKey(NULL, KEY_TOPICNAME);
		if(p_kv_topicname == NULL)
		{
			SDNMSG(SM_ERR, "KEY_TOPICNAME does not exist in the notify_sub_info message.\n");
			return -1;
		}

		p_kv_sublist = parse_message.getKey(NULL, KEY_SUBLIST);
		if(p_kv_sublist == NULL)
		{
			SDNMSG(SM_ERR, "KEY_SUBLIST does not exist in the notify_sub_info message.\n");
			return -1;
		}

		
		b_found = 0;

		LOCK(m_mutexNode_);
		
		for(iter = m_listPubsub.begin(); iter != m_listPubsub.end(); iter++)
		{
			if(((*iter).m_nameTopic.compare(p_kv_topicname->m_strValue) == 0)
				&& ((*iter).m_isPublisher == 1)
				&& ((*iter).m_isEvent == 1)
				&& (((*iter).m_statusPubsub == STATUS_PUBSUB_REGISTERED)
					|| (((*iter).m_statusPubsub == STATUS_PUBSUB_REGISTERING)
						&& ((*iter).m_statusPubsubRsp == STATUS_RSP_ACK))))
			{
				b_found = 1;

				(*iter).m_listPeer.clear();

				iter_key_value = p_kv_sublist->m_listKeyValue.begin();
				while(iter_key_value != p_kv_sublist->m_listKeyValue.end())
				{
					p_kv_sublist_sub = &(*iter_key_value);
				
					p_kv_hostname = parse_message.getKey(&p_kv_sublist_sub->m_listKeyValue, KEY_PARAM_HOSTNAME);
					p_kv_appname = parse_message.getKey(&p_kv_sublist_sub->m_listKeyValue, KEY_PARAM_APPNAME);
					p_kv_ipaddr = parse_message.getKey(&p_kv_sublist_sub->m_listKeyValue, KEY_PARAM_IP);
					if((p_kv_hostname == NULL) || (p_kv_appname == NULL) || (p_kv_ipaddr == NULL))
					{
						SDNMSG(SM_ERR, "KEY_PARAM is not complete in the notify_sub_info message.\n");
						UNLOCK(m_mutexNode_);
						return -1;
					}
				
					peer_info.m_nameHost = p_kv_hostname->m_strValue;
					peer_info.m_nameApp = p_kv_appname->m_strValue;
					peer_info.m_addrIp = p_kv_ipaddr->m_strValue;
					
					(*iter).m_listPeer.push_back(peer_info);
					iter_key_value++;
				}

				break;
			}
		}

		UNLOCK(m_mutexNode_);

		// wake-up publisher ack thread if any
		LOCK(m_mutexSubList);
		pthread_cond_broadcast(&m_condSubList);
		UNLOCK(m_mutexSubList);

		if(!b_found)
		{
			SDNMSG(SM_ERR, "Failed to find publisher for notify_sub_info\n");
			return -1;
		}
	}
	else if(p_kv_command->m_strValue.compare(VAL_CMD__ALIVE) == 0)
	{
		sendSimpleMessage_(KEY_CMD, VAL_CMD__ALIVE_ACK);
	}

	return 0;
}




